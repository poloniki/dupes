import re
import pandas as pd

import openai
from openai import OpenAI
import json
import os


API_KEY_OPENAI= os.getenv('API_KEY_OPENAI')
client = OpenAI(api_key=API_KEY_OPENAI)

def getting_distribution_ingredients(df: pd.DataFrame, col="ingredients_text", distribution_percentage=0.9):

    # Drop rows with null values
    df = df.dropna(subset=[col])

    # Clean and split ingredients
    df["ingredients_raw"] = df[col].apply(lambda x: re.sub(r'[^\w\s\-]+', '/n', x))

    # Split into lists
    ingredients_doubles = []
    for i in range(len(df["ingredients_raw"])):
        ingredients_doubles.append(df["ingredients_raw"].iloc[i].split('/n'))

    # Flatten list
    ingredients_all_double = []
    for x in ingredients_doubles:
        ingredients_all_double.extend(x)

    # Strip whitespace
    ingredients_all_double_stripped = []
    for each in ingredients_all_double:
        stripped = each.strip()
        if stripped != "":
            ingredients_all_double_stripped.append(stripped)

    # Create dataframe for counting
    dfnames = pd.DataFrame()
    dfnames["names"] = ingredients_all_double_stripped

    # Frequency calculation
    valuesdf = pd.DataFrame()
    valuesdf["names"] = dfnames.names.value_counts(normalize=True)

    # Cumulative sum
    valuesdf["csum"] = valuesdf["names"].cumsum()

    # Filter by % coverage
    valuesdf = valuesdf.loc[valuesdf["csum"] < distribution_percentage]

    # Return names as list
    names = valuesdf.index
    return names


def require_element_name(names: list):


    get_matches_declaration = [{
    "type": "function",
    "name": "get_ingredients",
    "description": "Get  chemical formula if its an chemical element if not return NAE.",
    "parameters": {
        "type": "object",
        "properties": {
            "formula": {
                "type": "string",
                "description": "The chemical formula of an element if exists otherwise NAE",
            },
            "active": {
                "type": "boolean",
                "description": "True if elements is active.",
            },
        },

    },
    }]

    result= []

    for name in names:
        input_list = [
        {"role": "user", "content": f"Value is: {name}"}
        ]

        try:

            response = client.responses.create(
            model="gpt-5-mini",
            instructions="Respond only with answer generated by a tool.",

            tools=get_matches_declaration,
            input=input_list,
            )


            breakpoint()
            json_respons = json.loads(response.output[1].arguments)

            result.append({
                "name": name,
                "formula": json_respons.get("formula"),
                "active": json_respons.get("active"),
            })
        except:
            print(f'Failed for {name}')



    df = pd.DataFrame(result)

    return df

if __name__ == "__main__":
    names = ['water', 'car']
    result =require_element_name(names=names)
    print(result)
